using UnityEngine;
using System.Collections.Generic;


namespace Ardunity
{
    [AddComponentMenu("ARDUnity/Reactor/Effect/JoyStickReactor")]
    public class JoyStickReactor : ArdunityReactor
    {
        public enum Direction
        {
            FORWARD,
            BACKWARD,
            LEFT,
            RIGHT,
            STOP
        }

        [Range(0f, 8f)]
        public float maxIntensity = 1f;
        public float moveRate = 1f;
        public int sensitivity = 10;
        //[Range(0f, 8f)]
        //public float cutoffIntensity = 0.5f;

        private Light _light;
        private IWireInput<float> _analogInput_x;
        private IWireInput<float> _analogInput_y;
        private IWireOutput<float> _analogOutput;
        private float _x = 0;
        private float _y = 0;

		private bool start;

        protected override void Awake()
        {
            base.Awake();

            _light = GetComponent<Light>();
        }

        // Use this for initialization
        void Start()
        {
			start = false;
        }

        void OnEnable()
        {
            if (_analogInput_x != null && _analogInput_y != null)
            {
                _x = maxIntensity * Mathf.Clamp(_analogInput_x.input, 0f, 1f);
                _y = maxIntensity * Mathf.Clamp(_analogInput_y.input, 0f, 1f);
            }
        }

		// Update is called once per frame
        void Update()
        {
            if (_analogInput_x != null && _analogInput_y != null)
            {
                //move object
				Debug.Log("X : " + _x.ToString() + " / Y : " + _y.ToString());

				// GetDirection 함수의 반환값으로 방향을 판별함
                switch (GetDirection())
                {
                    case 0: return;
					case 1: this.transform.position += Vector3.forward * moveRate * Time.deltaTime; break;
					case 2: this.transform.position += Vector3.back * moveRate * Time.deltaTime;  break;
					case 3: this.transform.position += Vector3.left * moveRate * Time.deltaTime; break;
					case 4: this.transform.position += Vector3.right * moveRate * Time.deltaTime; break;

					// x성분과 y성분 벡터를 더하여 대각선 이동 구현
					case 5: this.transform.position += Vector3.forward * moveRate * Time.deltaTime + Vector3.left * moveRate * Time.deltaTime; break;
					case 6: this.transform.position += Vector3.forward * moveRate * Time.deltaTime + Vector3.right * moveRate * Time.deltaTime;  break;
					case 7: this.transform.position += Vector3.back * moveRate * Time.deltaTime + Vector3.left * moveRate * Time.deltaTime; break;
					case 8 : this.transform.position += Vector3.back * moveRate * Time.deltaTime + Vector3.right * moveRate * Time.deltaTime;  break;
                }
            }
        }

		// 조이스틱으로 입력받는 값에 따라 각각의 방향을 반환함
        private int GetDirection()
        {
			// connect 전 입력받는 쓰레기값을 무시하기 위해 start 변수를 사용
			if (start == false && (int)_x != 0 && (int)_y != 0)
				start = true;
			if (start == false)
				return 0;

			// 기존 코드는 대각선으로 이동할 때 x와 y 값이 같으면 정지상태로 인식하는 문제가 있어서 
			// 정지상태를 기존 (int)_x == (int)_y에서 변경함
			if ((int)_x == 5 && (int)_y == 5)
				return 0; //Stop

			else if ((int)_x > 5 && (int)_y > 5)
					return 5; // Left forward
			else if ((int)_x < 5 && (int)_y > 5)
					return 6; // Right forward
			else if ((int)_x > 5 && (int)_y < 5)
					return 7; // Left backward
			else if ((int)_x < 5 && (int)_y < 5)
					return 8; // Right backward

			// 대각선 방향 추가
            else if ((int)_x == 5 && (int)_x < (int)_y)
					return 1;    //Forward
            else if ((int)_x == 5 && (int)_x > (int)_y)
					return 2;    //Backward
            else if ((int)_x > (int)_y && (int)_y == 5)
					return 3;    //Left
            else if ((int)_x < (int)_y && (int)_y == 5)
					return 4;    //Right
			
            else
					return 0;
        }


        private void OnAnalogInputChanged_X(float value)
        {
            if (!this.enabled)
                return;

            _x = maxIntensity * Mathf.Clamp(_analogInput_x.input, 0f, 1f) * sensitivity;
            
        }

        private void OnAnalogInputChanged_Y(float value)
        {
            if (!this.enabled)
                return;

            _y = maxIntensity * Mathf.Clamp(_analogInput_y.input, 0f, 1f) * sensitivity;
        }

        protected override void AddNode(List<Node> nodes)
        {
            base.AddNode(nodes);

            nodes.Add(new Node("x_Intensity", "X Intensity", typeof(IWireInput<float>), NodeType.WireFrom, "Input<float>"));
            nodes.Add(new Node("y_Intensity", "Y Intensity", typeof(IWireInput<float>), NodeType.WireFrom, "Input<float>"));
        }

        protected override void UpdateNode(Node node)
        {
           
            if (node.name.Equals("x_Intensity"))
            {
                node.updated = true;
                if (node.objectTarget == null && _analogInput_x == null)
                    return;

                if (node.objectTarget != null)
                {
                    if (node.objectTarget.Equals(_analogInput_x))
                        return;
                }

                if (_analogInput_x != null)
                    _analogInput_x.OnWireInputChanged -= OnAnalogInputChanged_X;

                _analogInput_x = node.objectTarget as IWireInput<float>;
                if (_analogInput_x != null)
                    _analogInput_x.OnWireInputChanged += OnAnalogInputChanged_X;
                else
                    node.objectTarget = null;

                return;
            }
            else if (node.name.Equals("y_Intensity"))
            {
                node.updated = true;
                if (node.objectTarget == null && _analogInput_y == null)
                    return;

                if (node.objectTarget != null)
                {
                    if (node.objectTarget.Equals(_analogInput_y))
                        return;
                }

                if (_analogInput_y != null)
                    _analogInput_y.OnWireInputChanged -= OnAnalogInputChanged_Y;

                _analogInput_y = node.objectTarget as IWireInput<float>;
                if (_analogInput_y != null)
                    _analogInput_y.OnWireInputChanged += OnAnalogInputChanged_Y;
                else
                    node.objectTarget = null;

                return;
            }

            base.UpdateNode(node);
        }
    }
}
